# Note:
  I used python to write the program and due to python's limitations on multi-processing  , I did not use a technique that I wanted called the Island model since it requires parellel processing (if run on the same machine) , and due to that I decided to use a sequential technique inspired by the Island Model , the technique proved much less efficient than a true parallel Island Model but it still alowed for a slight improvement to solution quality.(the method used is discussed below in the advanced technique section)

# TSP-solution-using-an-evolutioanry-algorithm
an Evolutionary algorithm to solve the TSP problem , using a method inspired by Island Model technique to  improve solution quality and preserve diversity in the population of candidate solutions
## Introduction
 This is an evolutionary algorithm to solve the TSP problem , The idea of TSP is: Given a number of cities and the distances of traveling between them , find a minimum length tour that visits each city once and then returns to the starting city.  The search space for TSP can get enormous the more cities we have ,the number of possible routes is a factorial of the number of locations to visit , so running through all the possibilities becomes too much to handle , Evolutionary algorithms introduce ways to find near optimal solutions in a reasonable time. 
 ### Evolutionary Algorithms (genetic algorithm)
 In a genetic algorithm we try to reach near optimal solution by using a process inspired from biological evolution , we first start out by creating a random poopulation of candidate solutions , then through an iterative process where each iteration is considered a generation , the population undergoes mutation and recombination , during these processes in our algorithm the candidate solutions with the better fitness are the ones selected to be recombined to create the new generation , there is a small chance in every iteration that the selected individual will undergo a mutation which will cause a parameter in the solution to be randomly changed (the way the change occurs should be implemented in a way that doesn't create invalid solutions for example : in the case of TSP , a city shouldn't be visited more than once in a tour). we can allow the program to run for a set number of generations , or until the desired solution is reached. after each generation , the fitness("solution quality") of our candidate soolutions should increase considerably.
## Methods
To build an evolutionary algorithm we need to build its basic components , we started by representing cities as objects from a City class that we wrote , they hold the coordinates for the city as well as a function to determine the distance from the city to its destination. Our candidate solutions will be represented as lists of Cities in a certain order. (Parameters for our algorithm : Population size = 400 , mating pool = 200 , mutation rate = 0.2 ,crossover rate : 0.9 , generation limit = 500) 
### Initialising the population : 
 to initialise our population we read the city information from a text file and then we create a City object for each city which is then stored in a list , after reading all of the cities  we will have our first tour , this tour will be randomly shuffled and added to our population until we reach the desired population size 
### Evaluating the fitness:
  in order to evaluate the fitness of each of our candidate solution we simply calculate the distance of each tour, we can also inverse this distance  so that the higher the fitness the better the solution , we inverse the fitness again whenever we want to represent the distance as output. We also improve the efficiency of our evaluation by pre-calculating the distances this is discussed further below. 
### Mutation: 
  we simply  use  swap mutation in our algorithm , however we modify the mutation chance so that it changes dynamically as the generations keep increasing , we discuss this further below. 
### Crossover : 
 for our crossover , we are using Ordered crossover because we can be sure that it will always provide  acceptable offspring so we don’t have to worry about invalid solutions. 
### Parent Selection:
 for parent selection we are using tournament selection with a tournament size of 10.
### Survivor Selection: 
  for our survivor selection we are using mu + lambda as we believe this will help us preserve better solutions.
## Further Discussion( improved mutation) :
 we have decided to use an improved mutation operator for our algorithm , this operator changes along the execution of our algorithm , this change is justified by the  fact that mutation  is a blind operation, which is somewhat effective at the earlier stage of evolution but at the later stage of evolution, the probability to produce better results with mutation becomes very small. So we change our operator using the following formula: mutation_chance = mutation_chance-(0.1*mutation_chance*(generations/generations_limit)) the formula used is from the research on improved mutation operator(“in references”). 
 ## Further Discussion (Evaluation optimization):
 we optimized our evaluation function by precalculating all the distances between each city and storing them in a list of lists , for example: the distance between city1 and city3 can be found by calling list[1][3] or between city 10 and city 5 by calling list[10][5] , this helps by removing the need to calculate the distance every time we need to evaluate a candidate solution 
 ## General Optimization: 
  in order to further optimize our algorithm we have to place a dynamic limitation on how many generations the algorithm will run , this limitation is that if we get the same best fitness in each generation for 10 consecutive generations we can say that the algorithm has converged and we have found a solution for this particular run , this way the algorithm doesn’t need to keep running for the rest of the generations until we reach the generation limit , by ending the algorithm this way it increases the speed in general.
 ## Advanced Technique(“Modified Island Model”):  
  in a normal island model different populations are evolved in parallel and after a number of generations we migrate(exchange) some individuals between the populations, this migration happens every time that number of generations is run (for example: every 10 generations) , this serves to improve the diversity of our algorithm and introduce new information from other populations into our algorithm which in turn helps us avoid local optima and reach a better solution most of the time . We use a Modified version of the Island model where we don’t use the parallelism (“due to python’s constraints on multi-processing”), instead we have developed a sequential Island Model where we run the first population and after a number of generation we store the best individuals we want to migrate in a list and then add that to another list , for example : after every 10 generation store the chosen individuals in a list and append the list to another one that will hold all our lists of individuals for future migrations; after the first population has finished evolving , we run a second population , in the second population every 10 generations we access a position in the list where we get the individuals that need to migrate , the position we access starts at 0 and after every 10 generations increases by 1 until we get all of the individuals that migrated from population 1 into population 2 where they replace individuals with worst fitness(each individual is copied only once). This Modified Island Model causes us to sacrifice a little bit of speed , but we believe it helps us reach better solutions at the end. 
 # Discussion :
  After running , we can observe  that our algorithm has performed as expected by lowering the distance of the city Tour significantly in a reasonable time . Thanks to evolutionary algorithms , problems with very large search spaces can be solved much faster and with near-optimal results , however our algorithm efficiency can be improved much further by introducing multi-processing concepts that’ll help us take full advantage of the computing power of multi-core computers and allow us to reduce the runtime considerably , for instance we wouldn’t need to sacrifice speed in our Modified Island Model had we been able to use different cores for each population. 
 
It is also advised to use more than 2 population when using the Island Model because the more we have the more diverse our populations will be and the more likely it’ll be that we reach optimal solutions. 
 
Another Idea to consider is to use different crossover / mutation operators for each population , because it’ll allow each population to almost certainly take a very different path in its evolution , and during migration it’ll allow us to combine all the benefits of all the possible operators while also mitigating any disadvantages since we only pass over the best individuals during migration.
# References :
 1- An Analysis of Island Models in Evolutionary Computation: https://cs.gmu.edu/~zskolick/pubs/skolicki05analysis.pdf 
 
2- A New Approach to Solve the TSP using an Improved Genetic Algorithm (improved mutation): http://www.ijfis.org/journal/download_pdf.php?spage=217&volume=11&number=4 
